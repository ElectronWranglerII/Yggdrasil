;* Yggdrasil (TM) Core Operating System (MCS-80/85): Memory Library Without Management
;* Copyright (C) DeRemee Systems, IXE Electronics LLC
;* Portions copyright IXE Electronics LLC, Republic Robotics,
;* FemtoLaunch, FemtoSat, FemtoTrack, Weland
;* This work is made available under the Creative Commons
;* Attribution-NonCommercial-ShareAlike 4.0 International License.
;* To view a copy of this license, visit
;* http://creativecommons.org/licenses/by-nc-sa/4.0/.


;+-----------------------------------+
;| MEMORY CONTROL BLOCK (MCB) FORMAT |
;+-----------------------------------+
;|           ENTRY 0 FLAGS           |
;+-----------------------------------+
;|           ENTRY 1 FLAGS           |
;+-----------------------------------+
;|     ENTRY ENTRYCOUNT - 2 FLAGS    |
;+-----------------------------------+
;|     ENTRY ENTRYCOUNT - 1 FLAGS    |
;+-----------------------------------+
;|          ENTRY 0 TASK ID          |
;+-----------------------------------+
;|          ENTRY 1 TASK ID          |
;+-----------------------------------+
;|    ENTRY ENTRYCOUNT - 2 TASK ID   |
;+-----------------------------------+
;|    ENTRY ENTRYCOUNT - 1 TASK ID   |
;+-----------------------------------+

;+-----------------------------------------------+
;|    MEMORY CONTROL BLOCK ENTRY FLAGS FORMAT    |
;+-----------------------------------------------+
;| RES | RES | CHI | PAR | FRE | REL | SWP | PRS |
;+-----------------------------------------------+
;PRS -	PRESENT. SET IF THE MEMORY FOR THE ENTRY IS PHYSICALLY PRESENT
;SWP -	SWAPPABLE. SET IF THE ENTRY IS SWAPPABLE TO SECONDARY STORAGE
;REL -	RELOCATABLE. SET IF THE ENTRY IS RELOCATABLE WITHIN RAM
;FRE -	FREE. SET IS THE MEMORY ENTRY IS FREE FOR ALLOCATION
;PAR -	PARENT. SET IF THIS ENTRY IS THE PARENT OF ONE OR MORE ENTRIES
;		IMMEDIATELY FOLLOWING IT
;CHI -	CHILD. SET IF THIS ENTRY IS THE CHILD OF THE ENTRY IMMEDIATELY
;		IMMEDIATELY PRECEDING IT OR THAT ENTRY'S PARENT
;RES -	RESERVED


MEM_OFFS_MCB_FLAGS		EQU	0x00
MEM_OFFS_MCB_TID		EQU	0x01


MEM_MCB_ENTRY_FLAG_PRS	EQU	0x01
MEM_MCB_ENTRY_FLAG_SWP	EQU	0x02
MEM_MCB_ENTRY_FLAG_REL	EQU	0x04
MEM_MCB_ENTRY_FLAG_FRE	EQU	0x08
MEM_MCB_ENTRY_FLAG_PAR	EQU	0x10
MEM_MCB_ENTRY_FLAG_CHI	EQU	0x20


MEM_MCB_BASE_ADDRESS	EQU	0x0040
MEM_STACK_ADDRESS		EQU	0x0000


;ALLOCATE MEMORY
;ON ENTRY:
;	BC	= NUMBER OF BYTES TO ALLOCATE
;ON RETURN:
;	BC	= VALUE ON ENTRY
;	CF	= 0 IF SUCCESS
;		A	= 0x00
;		HL	= MEMORY BLOCK BASE ADDRESS
;	CF	= 1 IF FAIL
;		A	= ERROR CODE
;		HL	= 0x0000
MEMALC:
	;SAVE REGISTERS
	PUSH	B
	PUSH	D
	;CALCULATE REQUIRED NUMBER OF MEMORY BLOCKS
	MOV		A, C
	ORA		C
	JZ		MEMALCA
	;ADJUST COUNT FOR FRACTIONS OF 256
	INR		B
MEMALCA:
	;BLOCK COUNT IS VALID?
	MOV		A, B
	ORA		B
	MVI		A, MEM_RET_ERR_INVSIZ
	JZ		MEMALCH
	;SAVE BLOCK COUNT
	MOV		C, B
	;LOAD MEMORY BLOCK COUNTER
	MVI		E, 0x00
	;LOAD MCB BASE ADDRESS
	LXI		H, MEM_MCB_BASE_ADDRESS
MEMALCB:
	;LOAD MCB ENTRY'S FLAGS
	MOV		A, M
	;ENTRY'S PRESENT & FREE FLAGS SET?
	ANI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	XRI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	JNZ		MEMALCE
	;DECREMENT BLOCK COUNT
	DCR		C
	;BLOCK COUNT == 0?
	JNZ		MEMALCF
	;POINT TO FIRST FREE BLOCK FOUND
	INX		H
	MOV		A, L
	SUB		B
	MOV		L, A
	MOV		A, H
	SBI		0x00
	MOV		H, A
	PUSH	H
	;MARK BLOCKS AS RESERVED
	MOV		C, B
MEMALCC:
	MOV		A, M
	ANI		255 - MEM_MCB_ENTRY_FLAG_FRE
	MOV		M, A
	INX		H
	DCR		C
	JNZ		MEMALCC
	;WRITE TASK ID TO MCB ENTRIES
	CALL	TASKCURR
	MOV		C, B
	POP		H
	JC		MEMALCH
	PUSH	H
	INR		H
MEMALCD:
	MOV		M, A
	INX		H
	DCR		C
	JNZ		MEMALCD
	;CALCULATE BASE ADDRESS
	POP		H
	LXI		D, 0 - MEM_MCB_BASE_ADDRESS
	DAD		D
	MOV		H, L
	MVI		L, 0x00
	;RESTORE REGISTERS & RETURN
	POP		D
	POP		B
	XRA		A
	RET
MEMALCE:
	;RESTORE BLOCK COUNT
	MOV		C, B
MEMALCF:
	;POINT TO NEXT MCB ENTRY
	INX		H
	;DECREMENT MEMORY BLOCK COUNTER
	DCR		E
	JNZ		MEMALCB
MEMALCG:
	;RESTORE REGISTERS & RETURN
	MVI		A, MEM_RET_ERR_NOFREE
MEMALCH:
	POP		D
	POP		B
	STC
	RET


;COPIES THE CONTENTS OF THE SOURCE MEMORY TO THE DESTINATION MEMORY
;ON ENTRY:
;	BC	= NUMBER OF BYTES TO COPY
;	DE	= DESTINATION ADDRESS
;	HL	= SOURCE ADDRESS
;ON RETURN:
;	BC	= VALUE ON ENTRY
;	DE	= VALUE ON ENTRY
;	HL	= VALUE ON ENTRY
;	CF	= 0 IF SUCCESS
;		A	= 0x00
;	CF	= 1 IF FAIL
;		A	= ERROR CODE
MEMCOPY:
	;SAVE REGISTERS
	PUSH	B
	PUSH	H
	PUSH	D
	;CALCULATE REQUIRED NUMBER OF MEMORY BLOCKS
	MOV		A, C
	ORA		C
	JZ		MEMCOPYA
	;ADJUST COUNT FOR FRACTIONS OF 256
	INR		B
MEMCOPYA:
	;BLOCK COUNT IS VALID?
	MOV		A, B
	ORA		B
	MVI		D, MEM_RET_ERR_INVSIZ
	JZ		MEMCOPYG
	;SAVE BLOCK COUNT
	MOV		C, B
	;VERIFY SOURCE BLOCK IS ALLOCATED AND OF CORRECT SIZE
	LXI		D, MEM_MCB_BASE_ADDRESS
	MOV		L, H
	MVI		H, 0x00
	DAD		D
	MVI		D, MEM_RET_ERR_INVSRC
MEMCOPYB:
	;
	MOV		A, M
	ANI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	XRI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	JZ		MEMCOPYG
	;
	INX		H
	;
	DCR		C
	;
	JNZ		MEMCOPYB
	;VERIFY DESTINATION BLOCK IS ALLOCATED AND OF CORRECT SIZE
	MOV		C, B
	POP		H
	PUSH	H
	LXI		D, MEM_MCB_BASE_ADDRESS
	MOV		L, H
	MVI		H, 0x00
	DAD		D
	MVI		D, MEM_RET_ERR_INVDST
MEMCOPYC:
	;
	MOV		A, M
	ANI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	XRI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	JZ		MEMCOPYG
	;
	INX		H
	;
	DCR		C
	;
	JNZ		MEMCOPYC
	;COPY MEMORY
	MVI		C, 0x00
	POP		D
	POP		H
	PUSH	D
	PUSH	H
MEMCOPYD:
	MOV		A, M
	STAX	D
	INX		D
	INX		H
	DCX		B
	MOV		A, B
	ORA		C
	JNZ		MEMCOPYD
	;RESTORE REGISTERS & RETURN
	POP		H
	POP		D
	POP		B
	ORA		A
	RET
MEMCOPYG:
	;RESTORE REGISTERS & RETURN
	MOV		A, D
	POP		H
	POP		D
	POP		B
	STC
	RET


;RETURNS THE AMOUNT OF FREE MEMORY, IN BYTES
;ON ENTRY:
;	NONE
;ON RETURN:
;	BC	= AMOUNT OF FREE MEMORY
MEMFREE:
	;SAVE REGISTERS
	PUSH	PSW
	PUSH	H
	;LOAD MCB BASE ADDRESS
	LXI		H, MEM_MCB_BASE_ADDRESS
	;CLEAR FREE MEMORY COUNTER & LOAD BLOCK COUNTER
	LXI		B, 0x0000
MEMFREEA:
	;LOAD MCB ENTRY'S FLAGS
	MOV		A, M
	ANI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	XRI		MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_FRE
	JNZ		MEMFREEB
	;INCREMENT FREE MEMORY COUNTER
	INR		B
MEMFREEB:
	;POINT TO NEXT MCB ENTRY
	INX		H
	;DECREMENT BLOCK COUNTER
	DCR		C
	JNZ		MEMFREEA
	;RESTORE REGISTERS & RETURN
	MVI		C, 0x00
	POP		H
	POP		PSW
	XRA		A
	RET
 
 
 ;INITIALIZE MEMORY
;ON ENTRY:
;	NONE
;ON RETURN:
;	CF	= 0 IF SUCCESS
;		A	= 0x00
;	CF	= 1 IF ERROR
;		A	= ERROR CODE
MEMINIT:
	;SAVE RETURN ADDRESS
	LXI		H, 0x0000
	DAD		SP
	MOV		C, M
	INX		H
	MOV		B, M
	;CLEAR MEMORY
	XRA		A
	LXI		D, 0x0001
	LXI		H, MEM_MCB_BASE_ADDRESS
MEMINITA:
	MOV		M, A
	DAD		D
	JNC		MEMINITA
	;RESERVE MEMORY FOR RESTART TABLE & MEMORY CONTROL BLOCK
	MVI		A, MEM_MCB_ENTRY_FLAG_PRS
	LXI		H, MEM_MCB_BASE_ADDRESS
	MOV		M, A
	INX		H
	MOV		M, A
	INX 	H
	MOV		M, A
	INX		H
	;MARK UNALLOCATED MEMORY AS FREE, SWAPPABLE & RELOCATABLE
	MVI		A, MEM_MCB_ENTRY_FLAG_PRS + MEM_MCB_ENTRY_FLAG_SWP + MEM_MCB_ENTRY_FLAG_REL + MEM_MCB_ENTRY_FLAG_FRE
	MVI		D, 0xFB
MEMINITB:
	MOV		M, A
	INX		H
	DCR		D
	JNZ		MEMINITB
	;RESERVE MEMORY FOR STACK
	MVI		A, MEM_MCB_ENTRY_FLAG_PRS
	MOV		M, A
	INX		H
	MOV		M, A
	;LOAD STACK POINTER
	LXI		SP, MEM_STACK_ADDRESS
	;RETURN TO CALLER
	MOV		H, B
	MOV		L, C
	PCHL


;RELEASE ALLOCATED MEMORY BLOCK
;ON ENTRY:
;	BC	= NUMBER OF BYTES TO RELEASE
;	HL	= MEMORY BLOCK BASE ADDRESS
;ON RETURN:
;	BC	= VALUE ON ENTRY
;	HL	= 0x0000
;	CF	= 0 IF SUCCESS
;		A	= 0x00
;	CF	= 1 IF FAIL
;		A	= ERROR CODE
MEMREL:
	;SAVE REGISTERS
	PUSH	B
	PUSH	D
	;CALCULATE REQUIRED NUMBER OF MEMORY BLOCKS
	MOV		A, C
	ORA		C
	JZ		MEMRELA
	;ADJUST COUNT FOR FRACTIONS OF 256
	INR		B
MEMRELA:
	;BLOCK COUNT IS VALID?
	MOV		A, B
	ORA		B
	JZ		MEMRELC
	;CALCULATE FIRST ENTRY'S MCB ADDRESS
	MOV		L, H
	MVI		H, 0x00
	LXI		D, MEM_MCB_BASE_ADDRESS
	DAD		D
MEMRELB:
	;MARK BLOCKS AS FREE
	MOV		A, M
	ORI		MEM_MCB_ENTRY_FLAG_FRE
	MOV		M, A
	INX		H
	DCR		B
	JNZ		MEMRELB
	;RESTORE REGISTERS & RETURN
	POP		D
	POP		B
	XRA		A
	RET
MEMRELC:
	;RESTORE REGISTERS & RETURN
	POP		D
	POP		B
	MVI		A, MEM_RET_ERR_INVSIZ
	STC
	RET
