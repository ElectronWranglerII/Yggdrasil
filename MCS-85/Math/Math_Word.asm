;COMPUTE 2 ^ X
;ON ENTRY:
;	BC	= X
;ON RETURN:
;	BC	= RESULT
LMATHWIU2X:
	;SAVE REGISTERS
	PUSH	PSW
	PUSH	H
	;X = 0?
	MOV		A, B
	ORA		C
	MVI		C, 001H
	JZ		LMATHWIU2XB
	;X != 0
	ANI		0FH
	;SET UP FOR SHIFTS
	LXI		H, 00001H
LMATHWIU2XA:
	;MULTIPLY RESULT BY TWO
	DAD		H
	;DECREMENT LOOP COUNTER
	DCR		A
	JNZ		LMATHWIU2XA
	;
	MOV		B, H
	MOV		C, L
LMATHWIU2XB:
	;RESTORE REGISTERS & RETURN
	POP		H
	POP		PSW
	RET


;COMPUTE 2 ^ X - 1
;ON ENTRY:
;	BC	= X
;ON RETURN:
;	BC	= RESULT
LMATHWIU2XM1:
	CALL	LMATHWIU2X
	DCX		B
	RET


;COMPUTES X + Y
;ON ENTRY:
;	CF	= CARRY IN
;	BC	= AUGEND
;	DE	= ADDEND
;ON RETURN:
;	CF	= CARRY OUT
;	BC	= SUM
;	DE	= VALUE ON ENTRY
LMATHWIUADD:
	MOV		A, C
	ADC		E
	MOV		C, A
	MOV		A, B
	ADC		D
	MOV		D, A
	RET


;COUNT LEADING ZEROS IN X
;ON ENTRY:
;	BC	= X
;ON RETURN:
;	A	= RESULT
;	BC	= VALUE ON ENTRY
LMATHWIUCLZ:		
	;SAVE REGISTERS
	PUSH	B
	;X == 0?
	MOV		A, B
	ORA		C
	JNZ		LMATHWIUCLZA
	;X == 0, RESTORE REGISTERS & RETURN
	MVI		A, 0x10
	POP		B
	RET
LMATHWIUCLZA:
	;X MSB ZERO?
	XRA		A
	ORA		B
	JNZ		LMATHWIUCLZB
	MOV		B, C
	CALL	LMATHBIUCLZ
	ADI		0x08
	JMP		LMATHWIUCLZC
LMATHWIUCLZB:
	CALL	LMATHBIUCLZ
LMATHWIUCLZC:
	;RESTORE REGISTERS & RETURN
	POP		B
	RET


;COUNT TRAILING ZEROS IN X
;ON ENTRY:
;	BC	= X
;ON RETURN:
;	A	= RESULT
;	BC	= VALUE ON ENTRY
LMATHWIUCTZ:
	;SAVE REGISTERS
	PUSH	B
	;REVERSE BIT ORDER
	CALL	LMATHBIUREV
	MOV		A, C
	MOV		C, B
	MOV		B, A
	CALL	LMATHBIUREV
	;
	CALL	LMATHWIUCLZ
	;RESTORE REGISTERS & RETURN
	POP		B
	RET

					
;COMPUTE X / Y
;ON ENTRY:
;	BC	= DIVIDEND
;	DE	= DIVISOR
;ON RETURN:
;	BC	= QUOTIENT
;	DE	= REMAINDER
LMATHWIUDIV:
	;CHECK FOR ZERO DIVIDEND
	MOV		A, B
	ORA		C
	JNZ		LMATHWIUDIVA
	;DIVIDEND IS ZERO, RETURN WITH ZERO RESULT
	MOV		D, A
	MOV		E, A
	;RESTORE REGISTERS & RETURN
	RET
LMATHWIUDIVA:
	;CHECK FOR ZERO DIVISOR
	MOV		A, D
	ORA		E
	JNZ		LMATHWIUDIVB
	;DIVISOR IS ZERO, RETURN WITH ERROR
	MVI		A, MATH_ERR_DIV_ZERO
	STC
	RET
LMATHWIUDIVB:
	;SAVE REGISTERS
	PUSH	H
	;ZEROIZE QUOTIENT
	LXI		H, 00000H
	PUSH	H
	;CLEAR CF
	STC
	CMC
	;
	XCHG
	XRA		A
LMATHWIUDIVC:
	;INCREMENT SHIFT COUNT
	INR		A
	;SHIFT DIVISOR LEFT UNTIL A LOGIC 1 IS IN MSB
	DAD		H
	;WAS THERE A LOGIC 1 IN THE MSB?
	JNC		LMATHWIUDIVC
	;MOVE DIVIDEND TO HL & SHIFT COUNT TO C
	XCHG
	MOV		H, B
	MOV		L, C
	MOV		C, A
LMATHWIUDIVE:	
	;SHIFT DIVISOR RIGHT ONE BIT
	MOV		A, D
	RAR
	MOV		D, A
	MOV		A, E
	RAR
	MOV		E, A
	;SUBTRACT DIVISOR FROM DIVIDEND
	MOV		A, L
	SUB		E
	MOV		L, A
	MOV		A, H
	SBB		D
	MOV		H, A
	;RESULT NEGATIVE?
	JNC		LMATHWIUDIVF
	;RESULT NEGATIVE, RESTORE DIVIDEND
	MOV		A, L
	ADD		E
	MOV		L, A
	MOV		A, H
	ADC		D
	MOV		H, A
LMATHWIUDIVF:	
	;COPY CF TO QUOTIENT
	XTHL
	CMC
	MOV		A, L
	RAL
	MOV		L, A
	MOV		A, H
	RAL
	MOV		H, A
	XTHL
	;SHIFT COUNT == 0?
	DCR		C
	JNZ		LMATHWIUDIVE
	;SHIFT COUNT == 0, MOVE REMAINDER TO DE
	MOV		E, L
	MOV		D, H
	;MOVE QUOTIENT TO BC
	POP		H
	MOV		B, H
	MOV		C, L
	;RESTORE REGISTERS & RETURN
	POP		H
	RET
	

;CALCULATES X * Y
;ON ENTRY:
;	BC	= X
;	DE	= Y
;ON RETURN:
;	BC	= PRODUCT MSW
;	DE	= PRODUCT LSW
;       AAAA
;     BBBB
;     CCCC
; + DDDD
;-------------
LMATHWIUMUL:
	;MULTIPLICAND ZERO?
	MOV		A, B
	ORA		C
	JZ		LMATHWIUMULZ
	;MULTIPLICAND NOT ZERO
	;MULTIPLIER ZERO?
	MOV		A, D
	ORA		E
	JZ		LMATHWIUMULZ
	;MULTIPLIER NOT ZERO
	PUSH	H
	MOV		H, B
	MOV		L, C
	;COMPUTE PARTIAL PRODUCT B * D
	MOV		B, H
	MOV		C, D
	CALL	LMATHBIUMUL
	PUSH	B
	;COMPUTE PARTIAL PRODUCT C * D
	MOV		B, D
	MOV		C, L
	CALL	LMATHBIUMUL
	PUSH	B
	;COMPUTE PARTIAL PRODUCT B * E
	MOV		B, H
	MOV		C, E
	CALL	LMATHBIUMUL
	PUSH	B
	;COMPUTE PARTIAL PRODUCT C * E
	MOV		B, E
	MOV		C, L
	CALL	LMATHBIUMUL
	;COMPUTE FINAL PRODUCT
	LXI		H, 0x0000
	DAD		SP
	MOV		E, C
	MOV		A, B
	ADD		M
	MOV     D, A
	MVI     A, 0x00
	ACI     0x00
	MOV     C, A
	INX     H
	INX     H
	MOV     A, M
	ADC     D
	MOV		D, A
	MVI     A, 0x00
	ADC     C
    DCX     H
    ADD     M
    MOV     C, A
    MVI     A, 0x00
	ACI     0x00
	MOV     B, A
	INX     H
	INX     H
	MOV     A, M
	ADD     C
	MOV     C, A
	MVI     A, 0x00
	ACI     0x00
	MOV     B, A
	INX     H
	MOV     A, M
	ADD     C
	MOV     C, A
	MOV     A, B
	ACI     0x00
	MOV     B, A
	INX     H
	MOV     A, M
	ADD     B
	MOV     B, A
	;RESTORE REGISTERS & RETURN
	POP     H
	POP     H
	POP     H
	POP     H
	RET
LMATHWIUMULZ:
	;MULTIPLIER OR MULTIPLICAND ZERO
	;ZEROIZE PRODUCT
	MOV		B, A
	MOV		C, A
	MOV		D, A
	MOV		E, A
	RET


;REVERSES THE ORDER OF BITS IN X
;ON ENTRY:
;	BC	= X
;ON RETURN:
;	BC	= RESULT
LMATHWIUREV:
	;SAVE REGISTERS
	PUSH	PSW
	;REVERSE BITS
	MOV		A, C
	CALL	LMATHBIUREV
	MOV		C, B
	MOV		B, A
	CALL	LMATHBIUREV
	;RESTORE REGISTERS & RETURN
	POP		PSW
	RET


;SHIFTS X LEFT BY Y BITS
;ON ENTRY:
;	BC	= X
;	A	= Y
;ON RETURN:
;	BC	= RESULT
;	A	= VALUE ON ENTRY
LMATHWIUSHL:
	;SAVE REGISTERS
	PUSH	H
	PUSH	PSW
	;Y == 0?
	ORA		A
	JNZ		LMATHWIUSHLB
LMATHWIUSHLA:
	;Y == 0, RETURN
	POP		PSW
	POP		H
	RET
LMATHWIUSHLB:
	;Y != 0
	MOV		H, B
	MOV		L, C
	;X == 0?
	MOV		A, B
	ORA		C
	JZ		LMATHWIUSHLA
	;X != 0
	POP		PSW
	MOV		B, A
	;CHECK FOR  SHIFT BY 1
	RAR
	JNC		LMATHWIUSHLC
	;SHIFT BY 1
	DAD		H
LMATHWIUSHLC:
	;CHECK FOR SHIFT BY 2
	RAR
	JNC		LMATHWIUSHLD
	;SHIFT BY 2
	DAD		H
	DAD		H
LMATHWIUSHLD:
	;CHECK FOR SHIFT BY 4
	RAR
	JNC		LMATHWIUSHLE
	;SHIFT BY 4
	DAD		H
	DAD		H
	DAD		H
	DAD		H
LMATHWIUSHLE:
	;CHECK FOR SHIFT BY 8
	RAR
	JNC		LMATHWIUSHLF
	;SHIFT BY 8
	DAD		H
	DAD		H
	DAD		H
	DAD		H
	DAD		H
	DAD		H
	DAD		H
	DAD		H
LMATHWIUSHLF:
	;RESTORE REGISTERS & RETURN
	MOV		A, B
	MOV		B, H
	MOV		C, L
	POP		H
	RET


;SHIFTS X RIGHT BY Y BITS
;ON ENTRY:
;	BC	= X
;	A	= Y
;ON RETURN:
;	BC	= RESULT
;	A	= VALUE ON ENTRY
LMATHWIUSHR:
	CALL	LMATHWIUREV
	CALL	LMATHWIUSHL
	CALL	LMATHWIUREV
	RET
					
					
;CALCULATES THE SQUARE ROOT OF X
;USES BABYLONIAN METHOD
;ON ENTRY:
;	BC	= X
;ON RETURN:
;	BC	= ROOT
LMATHWIUSQRT:		
	;SAVE REGISTERS
	PUSH	PSW
	PUSH	D
	PUSH	H
	;VALUE ZERO?
	MOV		A, B
	ORA		C
	JZ		LMATHWIUSQRTA
	;INITIAL ESTIMATE IS 256
	LXI		D, 00100H
	MOV		H, B
	MOV		L, C
	;FIRST ITERATION - DIVIDE X BY n0
	PUSH	D
	CALL	LMATHWIUDIV
	;FIRST ITERATION - ADD n0 TO QUOTIENT
	POP		D
	MOV		A, C
	ADD		E
	MOV		C, A
	MOV		A, B
	ADC		D
	MOV		B, A
	;FIRST ITERATION - DIVIDE RESULT BY 2
	ORA		A
	MOV		A, B
	RAR
	MOV		D, A
	MOV		A, C
	RAR
	MOV		E, A
	;SET UP FOR NEXT ITERATION
	MOV		B, H
	MOV		C, L
	;SECOND ITERATION - DIVIDE X BY n0
	PUSH	D
	CALL	LMATHWIUDIV
	;SECOND ITERATION - ADD n0 TO QUOTIENT
	POP		D
	MOV		A, C
	ADD		E
	MOV		C, A
	MOV		A, B
	ADC		D
	MOV		B, A
	;SECOND ITERATION - DIVIDE RESULT BY 2
	ORA		A
	MOV		A, B
	RAR
	MOV		D, A
	MOV		A, C
	RAR
	MOV		E, A
	;SET UP FOR NEXT ITERATION
	MOV		B, H
	MOV		C, L
	;THIRD ITERATION - DIVIDE X BY n0
	PUSH	D
	CALL	LMATHWIUDIV
	;THIRD ITERATION - ADD n0 TO QUOTIENT
	POP		D
	MOV		A, C
	ADD		E
	MOV		C, A
	MOV		A, B
	ADC		D
	MOV		B, A
	;THIRD ITERATION - DIVIDE RESULT BY 2
	ORA		A
	MOV		A, B
	RAR
	MOV		D, A
	MOV		A, C
	RAR
	MOV		E, A
	;SET UP FOR NEXT ITERATION
	MOV		B, H
	MOV		C, L
	;FOURTH ITERATION - DIVIDE X BY n0
	PUSH	D
	CALL	LMATHWIUDIV
	;FOURTH ITERATION - ADD n0 TO QUOTIENT
	POP		D
	MOV		A, C
	ADD		E
	MOV		C, A
	MOV		A, B
	ADC		D
	MOV		B, A
	;FOURTH ITERATION - DIVIDE RESULT BY 2
	ORA		A
	MOV		A, B
	RAR
	MOV		D, A
	MOV		A, C
	RAR
	MOV		E, A
	;SET UP FOR NEXT ITERATION
	MOV		B, D
	MOV		C, E
LMATHWIUSQRTA:
	;RESTORE REGISTERS & RETURN
	POP		H
	POP		D
	POP		PSW
	RET


;COMPUTES X - Y
;ON ENTRY:
;	CF	= BORROW IN
;	BC	= MINUEND
;	DE	= SUBTRAHEND
;ON RETURN:
;	CF	= BORROW OUT
;	BC	= DIFFERENCE
;	DE	= VALUE ON ENTRY
LMATHWIUSUB:
	MOV		A, C
	SBB		E
	MOV		C, A
	MOV		A, B
	SBB		D
	MOV		D, A
	RET
